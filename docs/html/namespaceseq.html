<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dendro: seq Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="dendro.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dendro
   &#160;<span id="projectnumber">5.01</span>
   </div>
   <div id="projectbrief">Dendro in Greek language means tree. The Dendro library is a large scale (262K cores on ORNL&#39;s Titan) distributed memory adaptive octree framework. The main goal of Dendro is to perform large scale multiphysics simulations efficeiently in mordern supercomputers. Dendro consists of efficient parallel data structures and algorithms to perform variational ( finite element) methods and finite difference mthods on 2:1 balanced arbitary adaptive octrees which enables the users to perform simulations raning from black holes (binary black hole mergers) to blood flow in human body, where applications ranging from relativity, astrophysics to biomedical engineering.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">seq Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Collection of Generic Sequential Functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0ffdcb61e596e75de51b49ad995478d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ffdcb61e596e75de51b49ad995478d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a0ffdcb61e596e75de51b49ad995478d0">flashsort</a> (T *a, int n, int m, int *ctr)</td></tr>
<tr class="memdesc:a0ffdcb61e596e75de51b49ad995478d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash sort algo to sort an array in O(n).  <a href="#a0ffdcb61e596e75de51b49ad995478d0">More...</a><br /></td></tr>
<tr class="separator:a0ffdcb61e596e75de51b49ad995478d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6ce94b3ad83bb2dda2cfb7db4b4931"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e6ce94b3ad83bb2dda2cfb7db4b4931"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a9e6ce94b3ad83bb2dda2cfb7db4b4931">BinarySearch</a> (const T *arr, unsigned int nelem, const T &amp;key, unsigned int *idx)</td></tr>
<tr class="memdesc:a9e6ce94b3ad83bb2dda2cfb7db4b4931"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binary search implementation.  <a href="#a9e6ce94b3ad83bb2dda2cfb7db4b4931">More...</a><br /></td></tr>
<tr class="separator:a9e6ce94b3ad83bb2dda2cfb7db4b4931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2cb0cb782ebbb6879b2bc72b9034e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a2cb0cb782ebbb6879b2bc72b9034e7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#a6a2cb0cb782ebbb6879b2bc72b9034e7">UpperBound</a> (unsigned int nelem, const T *arr, unsigned int startIdx, const T &amp;key)</td></tr>
<tr class="memdesc:a6a2cb0cb782ebbb6879b2bc72b9034e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the smallest upper bound of the search key in the array.  <a href="#a6a2cb0cb782ebbb6879b2bc72b9034e7">More...</a><br /></td></tr>
<tr class="separator:a6a2cb0cb782ebbb6879b2bc72b9034e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1891a3ddf195111c4ce3b8346ec60a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1891a3ddf195111c4ce3b8346ec60a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceseq.html#af1891a3ddf195111c4ce3b8346ec60a6">maxLowerBound</a> (const std::vector&lt; T &gt; &amp;arr, const T &amp;key, unsigned int &amp;retIdx, unsigned int *leftIdx, unsigned int *rightIdx)</td></tr>
<tr class="memdesc:af1891a3ddf195111c4ce3b8346ec60a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the greatest lower bound of the search key in the array. The implementation uses a simple modification of the binary search algorithm.  <a href="#af1891a3ddf195111c4ce3b8346ec60a6">More...</a><br /></td></tr>
<tr class="separator:af1891a3ddf195111c4ce3b8346ec60a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Collection of Generic Sequential Functions. </p>
<dl class="section author"><dt>Author</dt><dd>Rahul Sampath </dd>
<dd>
Milinda Fernando. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9e6ce94b3ad83bb2dda2cfb7db4b4931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6ce94b3ad83bb2dda2cfb7db4b4931">&#9670;&nbsp;</a></span>BinarySearch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::BinarySearch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nelem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A binary search implementation. </p>
<dl class="section author"><dt>Author</dt><dd>Rahul Sampath </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>A sorted array </td></tr>
    <tr><td class="paramname">nelem</td><td>The length of the array </td></tr>
    <tr><td class="paramname">key</td><td>The search key </td></tr>
    <tr><td class="paramname">idx</td><td>0-based index of the position of the key in the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the key exists in the array and 'false' otherwise </dd></dl>

</div>
</div>
<a id="a0ffdcb61e596e75de51b49ad995478d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffdcb61e596e75de51b49ad995478d0">&#9670;&nbsp;</a></span>flashsort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void seq::flashsort </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ctr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash sort algo to sort an array in O(n). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The array to be sorted </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in a </td></tr>
    <tr><td class="paramname">m</td><td>Size of index vector. typically m = 0.1*n </td></tr>
    <tr><td class="paramname">ctr</td><td>The number of times flashsort was called.</td></tr>
  </table>
  </dd>
</dl>
<p>Sorts array a with n elements by use of the index vector l of dimension m (with m about 0.1 n). The routine runs fastest with a uniform distribution of elements. The vector l is declare dynamically using the calloc function. The variable ctr counts the number of times that flashsort is called. THRESHOLD is a very important constant. It is the minimum number of elements required in a subclass before recursion is used.</p>
<p>Templated version of flashsort based on original C code by Karl-Dietrich Neubert. </p>

</div>
</div>
<a id="af1891a3ddf195111c4ce3b8346ec60a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1891a3ddf195111c4ce3b8346ec60a6">&#9670;&nbsp;</a></span>maxLowerBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool seq::maxLowerBound </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>retIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>leftIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>rightIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the index of the greatest lower bound of the search key in the array. The implementation uses a simple modification of the binary search algorithm. </p>
<dl class="section author"><dt>Author</dt><dd>Rahul Sampath </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>A sorted array </td></tr>
    <tr><td class="paramname">key</td><td>The search key </td></tr>
    <tr><td class="paramname">retIdx</td><td>The index of the position of the last element in the array &lt;= key </td></tr>
    <tr><td class="paramname">leftIdx</td><td>If this is not NULL, then the search will be limited to elements at positions &gt;= *leftIdx </td></tr>
    <tr><td class="paramname">rightIdx</td><td>if this is not NULL, then the search will be limited to elements at positions &lt;= *rightIdx </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the search was successful </dd></dl>

</div>
</div>
<a id="a6a2cb0cb782ebbb6879b2bc72b9034e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2cb0cb782ebbb6879b2bc72b9034e7">&#9670;&nbsp;</a></span>UpperBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int seq::UpperBound </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nelem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the index of the smallest upper bound of the search key in the array. </p>
<dl class="section author"><dt>Author</dt><dd>Santi Swaroop Adavani </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>A sorted array </td></tr>
    <tr><td class="paramname">nelem</td><td>The length of the array </td></tr>
    <tr><td class="paramname">startIdx</td><td>The starting location to search from </td></tr>
    <tr><td class="paramname">key</td><td>The search key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the first element in the array &gt;= key </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
